; Объявление внешних функций WinAPI

extern GetStdHandle: proc
  ; Функция для получения дескриптора потока ввода/вывода
  ; Параметр: RCX = номер потока (STD_OUTPUT_HANDLE или STD_INPUT_HANDLE)
  ; Возвращает: RAX = дескриптор потока

extern WriteConsoleA: proc
  ; Функция для записи ANSI-строки в консоль
  ; Параметры: RCX = дескриптор, RDX = адрес строки, R8 = длина, R9 = адрес для результата
  ; 5-й параметр на [RSP+32] должен быть 0
  ; Возвращает: RAX = статус (ненулевой если успешно)

extern ReadConsoleA: proc
  ; Функция для чтения ANSI-строки из консоли
  ; Параметры: RCX = дескриптор, RDX = адрес буфера, R8 = размер буфера
  ; R9 = адрес переменной для кол-ва прочитанных символов, [RSP+32] = 0
  ; Возвращает: RAX = статус, прочитанные данные в буфере, количество в переменной

extern lstrlenA: proc
  ; Функция для определения длины нуль-терминированной ANSI-строки
  ; Параметр: RCX = адрес строки (должна заканчиваться на 0)
  ; Возвращает: RAX = длина строки (без учета нулевого терминатора)

extern ExitProcess: proc
  ; Функция для завершения процесса
  ; Параметр: RCX = код выхода (0 = успех, !0 = ошибка)

.data

; Макрозамены для констант (номера стандартных потоков Windows)
STD_OUTPUT_HANDLE equ -11  ; Номер потока стандартного вывода (консоль для вывода)
STD_INPUT_HANDLE equ -10   ; Номер потока стандартного ввода (консоль для чтения)

; Дескрипторы потоков (будут заполнены при инициализации)
hStdInput qword ?          ; Дескриптор для чтения из консоли (получается из GetStdHandle)
hStdOutput qword ?         ; Дескриптор для записи в консоль (получается из GetStdHandle)

; Переменная для хранения константы (0x2C69 = 11369 в десятичной системе)
result qword 2C69h         ; Глобальная переменная, инициализирована константой

; Строки пользовательского интерфейса (все нуль-терминированы)
strA db "a = ", 0          ; Приглашение для ввода первого числа
strB db "b = ", 0          ; Приглашение для ввода второго числа
strConst db "const = 2C69h", 0dh, 0ah, 0  ; Вывод константы (\r\n в конце)
strF db "F = const + a - b = ", 0  ; Подпись для вывода результата F
strMin db "min(a, b) = ", 0         ; Подпись для вывода минимума
strInvalid db "Invalid character", 0dh, 0ah, 0  ; Ошибка: некорректный символ при вводе
strRange db "Number out of range", 0dh, 0ah, 0  ; Ошибка: число вне диапазона [-128, 127]
strExit db "Press any key to exit", 0dh, 0ah, 0 ; Сообщение перед ожиданием нажатия клавиши
strNext db " ", 0dh, 0ah, 0  ; Строка для переноса на новую линию (\r\n)
                             ; 0dh = символ возврата каретки, 0ah = символ перевода строки

; Макросы для работы со стеком

STACKALLOC macro arg
  ; Этот макрос выравнивает стек по 16-байтовой границе перед вызовом WinAPI функций
  ; arg - количество дополнительных qword параметров (сверх обязательных 4)
  
  push R15                ; Сохраняем значение R15 на стек (используем как временное хранилище)
  mov R15, RSP            ; Копируем текущее значение указателя стека в R15 для восстановления
  sub RSP, 8*4            ; Выделяем место под 4 обязательных аргумента (32 байта = 4 * 8)
  if arg                  ; Если макрос получил аргумент (количество доп. параметров)
    sub RSP, 8*arg        ; Выделяем дополнительное место (arg * 8 байт)
  endif
  and SPL, 0F0h           ; Выравниваем регистр SPL (нижний байт RSP) по 16-байтовой границе
                          ; Биты SPL становятся 0xF0 (последний полубайт = 0)
endm

STACKFREE macro
  ; Парный макрос для восстановления стека после завершения функции
  
  mov RSP, R15            ; Восстанавливаем значение стека из сохраненного R15
  pop R15                 ; Восстанавливаем значение самого R15 (обратный PUSH)
endm

NULL_FIFTH_ARG macro
  ; Устанавливает 5-й аргумент функции WinAPI в нуль (требуется для ReadConsoleA и WriteConsoleA)
  ; 5-й и последующие аргументы передаются на стеке, начиная с [RSP+32]
  
  mov qword ptr [RSP + 32], 0  ; Записываем 0 в позицию на стеке для 5-го параметра
                                ; qword ptr указывает что записываем 8-байтовое значение
endm

.code

; ===== ПРОЦЕДУРА ВЫВОДА СТРОКИ =====
; Выводит нуль-терминированную ANSI-строку в консоль
; Параметр (передается через стек): string - адрес строки для вывода
; Возвращаемое значение: нет (вывод в консоль)
; Сохраняемые регистры: RAX, RCX, RDX, R8, R9 (используются автоматически через 'uses')

PrintString proc uses RAX RCX RDX R8 R9, string: qword
  local bytesWritten: qword  ; Локальная переменная для хранения кол-ва записанных символов
  
  STACKALLOC 1               ; Выравниваем стек под 1 дополнительный параметр
  
  ; === ШАГ 1: Получение длины строки через lstrlenA ===
  mov RCX, string            ; RCX = адрес строки (1-й параметр для lstrlenA)
  call lstrlenA              ; Вызываем функцию: результат (длина) поместится в RAX
                             ; Функция сканирует строку пока не найдет 0, считает символы
  
  ; === ШАГ 2: Подготовка аргументов для WriteConsoleA ===
  mov RCX, hStdOutput        ; 1-й параметр (RCX): дескриптор потока вывода (консоль)
  mov RDX, string            ; 2-й параметр (RDX): адрес строки для вывода
  mov R8, RAX                ; 3-й параметр (R8): длина строки (получена из lstrlenA)
  lea R9, bytesWritten       ; 4-й параметр (R9): адрес переменной для сохранения кол-ва написанных символов
                             ; LEA загружает адрес (не содержимое) локальной переменной
  
  NULL_FIFTH_ARG             ; Устанавливаем 5-й параметр = 0 (требуется для WriteConsoleA)
  
  ; === ШАГ 3: Вывод строки ===
  call WriteConsoleA         ; Вызываем WinAPI функцию для вывода строки в консоль
                             ; После возврата: RAX содержит статус (0=ошибка, !0=успех)
  
  STACKFREE                  ; Восстанавливаем состояние стека (RSP и R15)
  
  ret 8                      ; Возвращаемся в место вызова и очищаем 1 параметр со стека (8 байт)
                             ; ret 8 = RET с удалением одного qword параметра
PrintString endp


; ===== ПРОЦЕДУРА ЧТЕНИЯ И ПРЕОБРАЗОВАНИЯ ЧИСЛА =====
; Читает строку из консоли и преобразует её в целое число (знаковое)
; Параметры: нет
; Возвращаемое значение: RAX = прочитанное число, R10 = статус ошибки (0=успех, 1=ошибка)
; Сохраняемые регистры: RBX, RCX, RDX, R8, R9 (используются автоматически)

ReadNumber proc uses RBX RCX RDX R8 R9
  local readStr[64]: byte    ; Локальный буфер на стеке для хранения прочитанной строки (64 байта)
  local bytesRead: dword     ; Локальная переменная для хранения фактически прочитанных байт (4 байта)
  
  STACKALLOC 2               ; Выравниваем стек под 2 дополнительных параметра
  
  ; === ШАГ 1: Чтение строки из консоли ===
  
  ; Подготовка параметров для ReadConsoleA:
  mov RCX, hStdInput         ; 1-й параметр: дескриптор потока ввода (консоль для чтения)
  lea RDX, readStr           ; 2-й параметр: адрес буфера для хранения прочитанной строки
                             ; LEA загружает адрес массива readStr на стеке
  mov R8, 64                 ; 3-й параметр: максимальный размер буфера (64 байта)
  lea R9, bytesRead          ; 4-й параметр: адрес переменной для сохранения кол-ва прочитанных символов
  NULL_FIFTH_ARG             ; 5-й параметр: 0 (требуется для консольного ввода)
  
  call ReadConsoleA          ; Вызываем функцию: БЛОКИРУЕТ выполнение до нажатия Enter
                             ; Результат: строка в readStr, количество символов в bytesRead
                             ; Примечание: Windows добавляет \r\n в конце строки!
  
  ; === ШАГ 2: Инициализация переменных для парсинга ===
  
  xor RBX, RBX               ; RBX = 0 (накопитель для итогового числа)
  xor RCX, RCX               ; RCX = 0 (временный счетчик позиции)
  
  ; === ШАГ 3: Расчет длины строки ===
  
  ; Получим длину строки (исключая \r\n)
  mov ECX, bytesRead         ; ECX = количество прочитанных символов (включает \r\n)
  sub ECX, 2                 ; Вычитаем 2 для удаления символов \r (0x0D) и \n (0x0A)
                             ; Теперь ECX содержит длину полезной информации
  
  ; === ШАГ 4: Инициализация множителя для степеней 10 ===
  
  ; Инициализируем R8 для степеней 10
  mov R8, 1                  ; R8 = 1 (начальная степень 10: 10^0)
                             ; На каждой итерации: 1 -> 10 -> 100 -> 1000 и т.д.
  
  ; === ШАГ 5: Начало сканирования строки ===
  
  ; Начнем сканирование строки с конца (справа налево, от младших цифр к старшим)
  cmp RCX, 0                 ; Проверяем не пустая ли строка
  jle scanningComplete       ; Если длина <= 0, переходим к завершению
  
scanning_loop:
  dec RCX                    ; RCX-- (переходим к предыдущей позиции в строке)
  cmp RCX, -1                ; Проверяем достигли ли начала строки (индекс -1 означает конец)
  je scanningComplete        ; Если да, выходим из цикла
  
  ; === ШАГ 6: Получение текущего символа ===
  
  ; Получим текущий символ из буфера
  xor RAX, RAX               ; Очищаем RAX (старшие биты)
  mov AL, readStr[RCX]       ; AL = текущий символ (readStr[RCX])
                             ; Используем AL так как это один байт
  
  ; === ШАГ 7: Проверка на минус (знак числа) ===
  
  ; Проверим на минус
  cmp AL, '-'                ; Сравниваем AL с кодом '-' (0x2D)
  je negate_and_complete     ; Если найден минус, меняем знак и выходим
  
  ; === ШАГ 8: Проверка диапазона символов '0' до '9' ===
  
  ; Проверим диапазон '0''9'
  ; ASCII коды: '0' = 0x30, '9' = 0x39
  cmp AL, 30h                ; Сравниваем AL с '0' (0x30)
  jl error                   ; Если меньше, ошибка (не цифра)
  cmp AL, 39h                ; Сравниваем AL с '9' (0x39)
  jg error                   ; Если больше, ошибка (не цифра)
  
  ; === ШАГ 9: Преобразование ASCII кода символа в цифру ===
  
  ; Преобразуем символ (ASCII) в цифру
  ; Вычитаем 0x30 ('0'): '0'(0x30) - 0x30 = 0, '1'(0x31) - 0x30 = 1, ..., '9'(0x39) - 0x30 = 9
  sub RAX, 30h               ; RAX = номер цифры (0-9)
  
  ; === ШАГ 10: Умножение на текущую степень 10 ===
  
  ; Умножим RAX на текущую степень 10
  ; На 1-й итерации (последняя цифра): R8 = 1 (т.е. 10^0)
  ; На 2-й итерации (вторая с конца): R8 = 10 (т.е. 10^1)
  ; На 3-й итерации (третья с конца): R8 = 100 (т.е. 10^2) и т.д.
  mul R8                     ; RAX = RAX * R8 (содержимое регистра R8 используется в умножении)
                             ; Результат: RAX = цифра * текущая степень 10
  
  ; === ШАГ 11: Добавление к накопителю ===
  
  ; Добавим к результату
  add RBX, RAX               ; RBX = RBX + RAX (добавляем в итоговое число)
  
  ; === ШАГ 12: Увеличение степени 10 ===
  
  ; Увеличим степень 10 (не просто add, а умножим на 10!)
  mov RAX, 10                ; RAX = 10
  mul R8                     ; RAX = 10 * R8 (умножаем R8 на 10)
  mov R8, RAX                ; R8 = RAX (сохраняем новую степень 10)
  
  ; === ШАГ 13: Переход на следующую итерацию ===
  
  jmp scanning_loop          ; Переходим на начало цикла для следующей цифры
  
  ; === ШАГ 14: Обработка минуса ===
  
negate_and_complete:
  neg RBX                    ; RBX = -RBX (меняем знак числа с помощью двойного дополнения)
  
  ; === ШАГ 15: Завершение успешно ===
  
scanningComplete:
  mov R10, 0                 ; R10 = 0 (статус = успех, нет ошибок)
  mov RAX, RBX               ; RAX = результирующее число (для возврата)
  jmp read_number_exit       ; Переходим на выход
  
  ; === ШАГ 16: Обработка ошибки ===
  
error:
  mov R10, 1                 ; R10 = 1 (статус = ошибка)
  
  ; === ШАГ 17: Выход из процедуры ===
  
read_number_exit:
  STACKFREE                  ; Восстанавливаем стек
  ret                        ; Возвращаемся в место вызова (без очистки - нет параметров)
ReadNumber endp


; ===== ПРОЦЕДУРА ВЫВОДА ЧИСЛА =====
; Преобразует число в строку и выводит её в консоль
; Параметр (передается через стек): number - числовое значение (знаковое)
; Возвращаемое значение: нет (вывод в консоль)
; Сохраняемые регистры: RAX, RCX, RDX, R8, R9, R10, R11 (автоматически)

PrintNumber proc uses RAX RCX RDX R8 R9 R10 R11, number: qword
  local numberStr[22]: byte  ; Локальный буфер для хранения строки числа (22 байта достаточно для 64-битного числа)
  
  STACKALLOC 1               ; Выравниваем стек
  
  ; === ШАГ 1: Инициализация счетчика позиции ===
  
  ; Инициализируем счетчик
  xor R8, R8                 ; R8 = 0 (индекс текущей позиции в массиве numberStr)
  
  ; === ШАГ 2: Загрузка числа ===
  
  ; Получим число
  mov RAX, number            ; RAX = параметр number (знаковое число 64-бит)
  
  ; === ШАГ 3: Проверка знака числа ===
  
  ; Проверим знак числа
  ; Бит 63 в 64-битном числе определяет знак (1 = отрицательное, 0 = положительное)
  bt result, 63              ; BT = Bit Test: проверяем 63-й бит переменной result
                             ; Результат заносится в флаг Carry
  jnc positive_number        ; JNC = Jump if Not Carry: если бит 63 = 0, переходим на positive_number
                             ; Это проверка знака результата
  
  ; === ШАГ 4: Обработка отрицательного числа ===
  
  ; Число отрицательное
  mov numberStr[0], '-'      ; numberStr[0] = '-' (первый символ будет минус)
                             ; ASCII код '-' = 0x2D
  inc R8                     ; R8 = 1 (следующая позиция свободна)
  neg RAX                    ; RAX = -RAX (преобразуем число в положительное для работы)
                             ; Двойное дополнение: негативное число становится позитивным
  
  ; === ШАГ 5: Инициализация переменных для деления ===
  
positive_number:
  mov RBX, 10                ; RBX = 10 (делитель для получения цифр)
  xor RCX, RCX               ; RCX = 0 (счетчик цифр на стеке)
  
  ; === ШАГ 6: Деление числа на 10 в цикле ===
  
division_loop:
  xor RDX, RDX               ; RDX = 0 (обязательно очищаем перед делением!)
                             ; Инструкция div использует RDX:RAX (128-битное делимое)
  div RBX                    ; Делим RDX:RAX на RBX (10)
                             ; Результат: RAX = частное, RDX = остаток (последняя цифра!)
  
  ; === ШАГ 7: Преобразование остатка в ASCII символ ===
  
  ; Преобразуем остаток в ASCII код
  ; RDX содержит остаток 0-9, добавляем 0x30 чтобы получить '0'-'9'
  add RDX, '0'               ; RDX = RDX + 0x30 (0 -> '0', 1 -> '1', ..., 9 -> '9')
  
  ; === ШАГ 8: Размещение цифры на стеке (в обратном порядке) ===
  
  ; Поместим в стек
  push RDX                   ; Кладем ASCII код цифры на стек
                             ; Стек работает LIFO: последняя отправленная цифра будет первой извлеченной
  inc RCX                    ; RCX++ (увеличиваем счетчик количества цифр)
  
  ; === ШАГ 9: Проверка завершения деления ===
  
  ; Проверим, закончилось ли деление
  ; Если RAX = 0, значит мы разделили число полностью и больше нет цифр
  cmp RAX, 0                 ; Сравниваем RAX с 0
  jne division_loop          ; Если RAX != 0, переходим на начало цикла для следующей цифры
  
  ; === ШАГ 10: Перенос цифр со стека в строку в правильном порядке ===
  
stack_to_string:
  cmp RCX, 0                 ; Проверяем есть ли еще цифры на стеке
  je string_complete         ; Если RCX = 0, все цифры перенесены, переходим на завершение
  
  ; Возьмем цифру из стека
  pop RDX                    ; Извлекаем ASCII код цифры со стека в RDX
  mov numberStr[R8], DL      ; numberStr[R8] = DL (нижний байт RDX содержит ASCII символ)
                             ; Используем DL так как это один байт (символ)
  inc R8                     ; R8++ (переходим к следующей позиции в строке)
  
  dec RCX                    ; RCX-- (уменьшаем счетчик оставшихся цифр)
  jmp stack_to_string        ; Переходим на начало цикла для следующей цифры
  
  ; === ШАГ 11: Добавление нуль-терминатора ===
  
string_complete:
  ; Добавим нуль-терминатор
  mov numberStr[R8], 0       ; numberStr[R8] = 0 (завершаем строку нулевым байтом)
                             ; Это требуется для функции lstrlenA и WriteConsoleA
                             ; Теперь numberStr содержит валидную C-строку (ASCIIZ)
  
  ; === ШАГ 12: Вывод полученной строки ===
  
  ; Выведем строку
  lea RAX, numberStr         ; RAX = адрес начала строки (используем LEA для получения адреса)
  push RAX                   ; Помещаем адрес на стек как параметр для PrintString
  call PrintString           ; Вызываем процедуру вывода строки
                             ; PrintString очистит стек параметра сама (ret 8)
  
  STACKFREE                  ; Восстанавливаем стек (RSP и R15)
  
  ret 8                      ; Возвращаемся и очищаем 1 параметр (8 байт - число)
PrintNumber endp


; ===== ПРОЦЕДУРА ОЖИДАНИЯ ВВОДА =====
; Выводит сообщение и ждет нажатия клавиши (аналог getch())
; Параметры: нет
; Возвращаемое значение: нет
; Сохраняемые регистры: RAX, RCX, RDX, R8, R9, R10, R11 (автоматически)

WaitForInput proc uses RAX RCX RDX R8 R9 R10 R11
  local readStr[64]: byte    ; Буфер для чтения символа (хотя используется только 1-2 символа)
  local bytesRead: dword     ; Количество прочитанных символов
  
  STACKALLOC 1               ; Выравниваем стек
  
  ; === ШАГ 1: Подготовка вывода сообщения ===
  
  ; Выведем сообщение
  mov RCX, hStdOutput        ; 1-й параметр: дескриптор потока вывода
  lea RDX, strExit           ; 2-й параметр: адрес строки "Press any key to exit..."
  mov RAX, offset strExit    ; RAX = адрес строки (используем offset для получения адреса)
  call lstrlenA              ; Получаем длину строки, результат в RAX
  mov R8, RAX                ; 3-й параметр: длина строки
  lea R9, bytesRead          ; 4-й параметр: адрес переменной для результата
  NULL_FIFTH_ARG             ; 5-й параметр = 0
  
  call WriteConsoleA         ; Выводим сообщение в консоль
  
  ; === ШАГ 2: Ожидание ввода символа ===
  
  ; Прочтем один символ
  mov RCX, hStdInput         ; 1-й параметр: дескриптор потока ввода
  lea RDX, readStr           ; 2-й параметр: адрес буфера для символа
  mov R8, 1                  ; 3-й параметр: максимум 1 символ (+ \r\n которые Windows добавляет)
  lea R9, bytesRead          ; 4-й параметр: адрес переменной для кол-ва прочитанных символов
  NULL_FIFTH_ARG             ; 5-й параметр = 0
  
  call ReadConsoleA          ; БЛОКИРУЕТ выполнение до нажатия Enter
                             ; Функция ждет ввода пользователя
  
  STACKFREE                  ; Восстанавливаем стек
  
  ret                        ; Возвращаемся (нет параметров для очистки)
WaitForInput endp


; ===== ПРОЦЕДУРА ПЕРЕНОСА НА НОВУЮ СТРОКУ =====
; Выводит символы новой строки (\r\n) в консоль

nextLine proc
  ; Перейдем на новую строку
  lea RAX, strNext           ; RAX = адрес строки с \r\n
  push RAX                   ; Помещаем адрес на стек как параметр для PrintString
  call PrintString           ; Вызываем вывод строки (которая содержит только \r\n)
  ret                        ; Возвращаемся
nextLine endp


; ===== ПРОЦЕДУРА ПРОВЕРКИ ДИАПАЗОНА =====
; Проверяет находится ли число в диапазоне знакового байта [-128, 127]
; Параметр: RAX = число для проверки
; Возвращаемое значение: R11 = 0 (если в диапазоне) или R11 = 1 (если переполнение)

byteCheck proc
  ; Проверяет находится ли число в диапазоне byte [-128, 127]
  ; Число должно находиться в RAX
  ; Сделает R11 = 0, если число не выходит за пределы и R11 = 1 в противном случае
  
  cmp RAX, 127               ; Сравниваем число с верхней границей знакового байта (127)
  jg overflow                ; Если число > 127, то переполнение - переходим на overflow
  
  cmp RAX, -128              ; Сравниваем число с нижней границей знакового байта (-128)
  jl overflow                ; Если число < -128, то переполнение - переходим на overflow
  
  ; === Число в диапазоне ===
  mov R11, 0                 ; R11 = 0 (если переполнения нет, то статус = успех)
  ret                        ; Возвращаемся
  
overflow:
  ; === Число выходит за пределы диапазона ===
  mov R11, 1                 ; R11 = 1 (если переполнение есть, то статус = ошибка)
  ret                        ; Возвращаемся
byteCheck endp


; ===== ГЛАВНАЯ ПРОЦЕДУРА =====
; Основная функция программы - точка входа (mainCRTStartup для консольного приложения)

mainCRTStartup proc
  STACKALLOC                 ; Выравниваем стек (без дополнительных параметров)
  
  ; === ШАГ 1: Инициализация дескрипторов консоли ===
  
  ; Получим дескриптор для вывода
  mov RCX, STD_OUTPUT_HANDLE ; 1-й параметр: номер потока вывода (-11)
  call GetStdHandle          ; Вызываем функцию: возвращает дескриптор в RAX
  mov hStdOutput, RAX        ; Сохраняем дескриптор в глобальную переменную
  
  ; Получим дескриптор для ввода
  mov RCX, STD_INPUT_HANDLE  ; 1-й параметр: номер потока ввода (-10)
  call GetStdHandle          ; Вызываем функцию: возвращает дескриптор в RAX
  mov hStdInput, RAX         ; Сохраняем дескриптор в глобальную переменную
  
  ; === ШАГ 2: Вывод константы ===
  
  ; Выведем "const = 2C69h"
  lea RAX, strConst          ; RAX = адрес строки
  push RAX                   ; Помещаем адрес на стек как параметр
  call PrintString           ; Вызываем вывод
  
  ; === ШАГ 3: Ввод первого числа ===
  
  ; Выведем "a = "
  lea RAX, strA              ; RAX = адрес строки приглашения
  push RAX                   ; Помещаем адрес на стек как параметр
  call PrintString           ; Выводим приглашение
  
  ; Прочтем первое число
  call ReadNumber            ; Читаем число, результат в RAX, статус в R10
  call byteCheck             ; Проверяем попадает ли число в диапазон [-128, 127], статус в R11
  
  ; Проверим ошибку при чтении
  cmp R10, 1                 ; Если R10 = 1, то была ошибка парсинга
  je input_error             ; Переходим на обработку ошибки
  
  ; Проверим переполнение
  cmp R11, 1                 ; Если R11 = 1, то число вне диапазона
  je range_error             ; Переходим на обработку ошибки переполнения
  
  ; Сохраним первое число в RBX
  mov RBX, RAX               ; RBX = первое число (будет использоваться дальше)
  
  ; === ШАГ 4: Ввод второго числа ===
  
  ; Выведем "b = "
  lea RAX, strB              ; RAX = адрес строки приглашения
  push RAX                   ; Помещаем адрес на стек как параметр
  call PrintString           ; Выводим приглашение
  
  ; Прочтем второе число
  call ReadNumber            ; Читаем число, результат в RAX, статус в R10
  call byteCheck             ; Проверяем попадает ли число в диапазон [-128, 127], статус в R11
  
  ; Проверим ошибку при чтении
  cmp R10, 1                 ; Если R10 = 1, то была ошибка парсинга
  je input_error             ; Переходим на обработку ошибки
  
  ; Проверим переполнение
  cmp R11, 1                 ; Если R11 = 1, то число вне диапазона
  je range_error             ; Переходим на обработку ошибки переполнения

  ; === ШАГ 5: Вычисление результатов ===
  
  ; (Остальная часть программы продолжается здесь, но сокращена в примере)
  
input_error:
  ; === ОБРАБОТКА ОШИБКИ ПАРСИНГА ===
  
  ; Выведем сообщение об ошибке
  lea RAX, strInvalid        ; RAX = адрес строки ошибки "Invalid character"
  push RAX                   ; Помещаем адрес на стек как параметр
  call PrintString           ; Выводим сообщение об ошибке
  
  ; Ожидаем ввода
  call WaitForInput          ; Ждем нажатия клавиши пользователем
  
  ; Завершим программу с кодом ошибки
  mov RCX, 1                 ; 1-й параметр: код выхода = 1 (ошибка)
  call ExitProcess           ; Завершаем процесс

range_error:
  ; === ОБРАБОТКА ОШИБКИ ПЕРЕПОЛНЕНИЯ ===
  
  ; Выведем сообщение об ошибке переполнения
  lea RAX, strRange          ; RAX = адрес строки ошибки "Number out of range"
  push RAX                   ; Помещаем адрес на стек как параметр
  call PrintString           ; Выводим сообщение об ошибке
  
  ; Ожидаем ввода
  call WaitForInput          ; Ждем нажатия клавиши пользователем
  
  ; Завершим программу с кодом ошибки
  mov RCX, 1                 ; 1-й параметр: код выхода = 1 (ошибка)
  call ExitProcess           ; Завершаем процесс

mainCRTStartup endp

end
