#import "conf.typ" : conf
#show: conf.with(
  title: [Лабораторная работа №3],
  type: "referat",
  info: (
      author: (
        name: [Железко Александра Дмитриевича],
        faculty: [КНиИТ],
        group: "251",
        sex: "male"
      ),
      inspector: (
        degree: "Cтарший преподаватель",
        name: "Е. М. Черноусова"
      )
  ),
  settings: (
    title_page: (
      enabled: true
    ),
    contents_page: (
      enabled: true
    )
  )
)

= Исходный код программ
== Задание 1
В регистре AX задано число от 0 до 65535. Выведите это число на экран. (Проверить программу для числа более 2600)

#align(center)[#image("sections/task1.jpg")]
#text(size: 12pt, align(center)[Фото запуска первой программы])

```nasm
.model small
.stack 100h

.data 
Names db 'Alexander Zhelezko 251', 0Dh, 0Ah, '$'

.code

start:
mov AX, @data 
mov DS, AX 
mov DX, offset Names
mov AH, 09h
int 21h
mov AX, 1500 ; занесение числа
mov BX, 10 ; занесение делителя
mov CX, 0 ; обнуляем счётчик

breakNum: ; заносим в стек цифры
  inc CX ; увеличение счётчика
  mov DX, 0 ; очищение значения DX
  div BX ; деление AX на BX
  push DX ; занесение остатка от деление в стек
  cmp AX, 0 ; сравнение частного с нулем
  jne breakNum ; если AX != 0, то возвращаемся к breakNum

printNum:
  pop DX
  call printElem
  loop printNum

mov AX, 4C00h
int 21h

printElem proc
  push AX
  mov AH, 09h
  add DX, 30h 
  int 21h 
  pop AX
  ret 
printElem endp

end start
```
#text(size: 12pt, align(center)[Код первой программы])

#pagebreak()

== Задание 2
Используя 32-битные регистры процессора (EAX, EBX, EDX), напишите программу, выводящую на экран число 65536. Число 65536 изначально поместить в регистр EAX.

#align(center)[#image("sections/task2.jpg")]
#text(size: 12pt, align(center)[Фото запуска второй программы])

```nasm
.model small
.stack 100h
.386

.data 
Names db 'Alexander Zhelezko 251', 0Dh, 0Ah, '$'

.code

start:
mov AX, @data 
mov DS, AX
mov DX, offset Names
mov AH, 09h
int 21h

mov EAX, 65536 
mov EBX, 10 
mov CX, 0 ;обнуление счётчика

breakBigNum: ;заносим в стек
  inc CX ;увеличение счётчика
  mov EDX, 0 ;очищение значения EDX
  div EBX ;деление EAX на EBX
  push EDX ;занесение остатка от деление в стек
  cmp EAX, 0 ;сравнение частного с нулем
  jne breakBigNum ;если EAX != 0, то возвращаемся к breakBigNum

printNum: 
  pop EDX 
  call cout 
  loop printNum

mov EAX, 4C00h
int 21h

printElem proc
  push EAX
  mov AH, 09h
  add EDX, 30h 
  int 21h 
  pop EAX
  ret 
printElem endp

end start
```
#text(size: 12pt, align(center)[Код второй программы])

= Ответы на контрольные вопросы
== Чем отличается деление на байт от деления на слово? (где должно располагаться делимое, куда попадут частное от деления и остаток от деления)

Байтовая команда делит 16-битовое делимое на 8-битовый делитель. Делимое находится в регистре AX . В результате деления получается два числа: частное помещается в регистр AL , а остаток – в AH .

Команда, работающая со словами, делит 32-битовое делимое на 16-битовый делитель. Делимое находится в паре регистров DX : AX, причем регистр DX содержит старшую значимую часть, а регистр AX – младшую. Команда деления помещает частное в регистр AX, а остаток в DX .


== Каков механизм действия команды CMP?
Команда сравнения CMP сравнивает два числа, вычитая второе из первого. Инструкция CMP не сохраняет результат, а лишь устанавливает в соответствии с результатом флаги состояния. Основное назначение команды CMP – это организация ветвлений (условных переходов) в ассемблерных программах.
- ZF (Zero Flag): устанавливается, если операнды равны.
- CF (Carry Flag): устанавливается, если первый операнд меньше второго (для беззнаковых чисел).
- SF (Sign Flag): устанавливается, если результат отрицательный (для знаковых чисел).
- OF (Overflow Flag): устанавливается при переполнении знакового результата.

== На какие флаги реагируют команды условного перехода для чисел со знаком и для чисел без знака?

Для чисел со знаком: JG (SF = OF и ZF = 0), JL (SF ≠ OF), JE (ZF = 1)

Для чисел без знака: JA (CF = 0 и ZF = 0), JB (CF = 1), JE (ZF = 1)

== С помощью команд условного и безусловного перехода выполните программную реализацию алгоритма ветвления для определения наименьшего числа из двух заданных.

```nasm
.model small
.stack 100h
.data 
  result db ?
.code

start:
mov R1, 4       
mov R2, 30        

mov AL, R1       ; Загружаем первое число в AL
cmp AL, R2       ; Сравниваем с вторым числом
jle R2_is_less   ; Если R1 <= R2, переход к метке
                 ; Если R1 больше R2
mov result, R1   ; Сохраняем R1 как результат
jmp notRealEnd   ; Переход к завершению

R2_is_less:
    mov result, R2   ; Сохраняем R2 как результат

notRealEnd:
  mov ax, 4C00h
  int 21h

end start
```

== Каков механизм работы команды организации цикла LOOP? 
Она в конце каждой итерации уменьшает содержимое CX на 1 и передает управление на метку (указанную в команде), если содержимое CX не равно 0. Если вычитание 1 из CX привело к нулевому результату, выполняется следующая команда.

== Как с помощью команды сдвига можно умножить знаковое число, хранящееся в АХ, на 2 в n-ой степени? 
```nasm
mov ax, 3        ; Пример числа (3)
shl ax, 2        ; Умножаем на 4 (6 * 4 = 24)
```
Каждый сдвиг влево увеличивает степень двойки.

== Как с помощью команды сдвига проверить содержимое регистра ВХ на четность?
Чтобы проверить четность числа в регистре BX, можно использовать команду сдвига вправо (shr) и jnc - если флаг переноса в регистре состояния установлен в 0, она передает управление на метку.
Если после сдвига младший бит равен нулю (нет переноса), то число четное.